---
title: 'Axum By Example'
excerpt: "The only way to understand code better. Is to keep reading
more and more code. There exists a github repo of solid examples. The
perfect place to learn more."
coverImage: '/assets/blog/img_bin/axum_by_example_wizard_1.png'
date: '2023-07-17T07:06:39.211Z'
author:
  name: 'Justin Bender'
  picture: '/assets/blog/authors/bender.png'
ogImage:
  url: '/assets/blog/img_bin/axum_by_example_wizard_1.png'
---

# Axum By Example

> ðŸ¦€ One of the best ways to understand code is to read more of it.

I would like to take a second to welcome you to this article. I hope
you're having a great day. Be safe and have fun!

[axum examples](https://github.com/tokio-rs/axum/tree/main/examples)

## Let's start with JSON Web Tokens

[axum JWT example](https://github.com/tokio-rs/axum/tree/main/examples/jwt)

The dependencies are going to be different on every project. So we will
start with the `Cargo.toml` to understand what will be compiled into
this project.

`Cargo.toml`:

```toml
[package]
name = "example-jwt"
version = "0.1.0"
edition = "2021"
publish = false

[dependencies]
axum = { path = "../../axum" }
axum-extra = { path = "../../axum-extra", features = ["typed-header"] }
jsonwebtoken = "8.0"
once_cell = "1.8"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tokio = { version = "1.0", features = ["full"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
```

* `Lazy`: is a type provided by the `once_cell` crate, from the sync
  module. It creates a static variables that initializes lazily. What
  does that mean? Well it will come into the program when it is used.
  After initialization. You can the access it from the programs data. It
  allows it to be initialized once. Even if there are concurrent
  threads.

A very simple configuration file. If you don't know about JSON Web
Tokens I recommend reading more about it.

* [JSON Web Tokens - jwt.io](https://jwt.io/)

It's one of the ways we can validate someone can access API. This isn't
the most secure method in the world but it is a highly used on. You will
want to have extra protects as well. For example, possibly keeping track
of the IP addresses being accessed from or other trigger to know that
someone malicious has access to the token.

At the very minimum if someone steals your JWT. They could use that to
log in and become you on the website. How? Well it's how we validate. If
they can validate. They become you.

`main.rs`:

```rust
//! Example JWT authorization/authetication
//!
//! Run with
//!
//! ```not_rust
//! JWT_SECRET=secret cargo run -p example-jwt
//! ```.

use axum::{
  async_trait,
  extract::FromRequestParts,
  http::{request::Parts, StatusCode},
  response::{IntoResponse, Response},
  routing::{get, post},
  Json, RequestPartsExt, Router,
};
use axum_extra::{
  headers::{authorization::Bearer, Authorization},
  TypedHeader,
};
use jsonwebtoken::{decode, encode, DecodingKey, EncodingKey, Header,
Validation};
use once_cell::sync::Lazy;
use serde::{Deserialize, Serialize};
use serde_json::json;
use std::fmt::Display;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

// Quick instructions
//
// - get an authorization token:
//
// curl -s \
//     -w '\n' \
//     -H 'Content-Type: application/json' \
//     -d '{"client_id":"foo","client_secret":"bar"}' \
//     http://localhost:3000/authorize
//
// - visit the protected area using the authorized token
//
// curl -s \
//     -w '\n' \
//     -H 'Content-Type: application/json' \
//     -H 'Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJiQGIuY29tIiwiY29tcGFueSI6IkFDTUUiLCJleHAiOjEwMDAwMDAwMDAwfQ.M3LAZmrzUkXDC1q5mSzFAs_kJrwuKz3jOoDmjJ0G4gM' \
//     http://localhost:3000/protected
//
// - try to visit the protected area using an invalid token
//
// curl -s \
//     -w '\n' \
//     -H 'Content-Type: application/json' \
//     -H 'Authorization: Bearer blahblahblah' \
//     http://localhost:3000/protected

static KEYS: Lazy<Keys> = Lazy::new(|| {
  let secret = std::env::var("JWT_SECRET").expect("JWT_SECRET must be
  set");
  Keys::new(secret.as_bytes())
});

#[tokio::main]
async fn main() {
  tracing_subscriber::registry()
    .with(
      tracing_subscriber::EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| "example_jwt=debug".into()),
    )
    .with(tracing_subscriber::fmt::layer())
    .init();

  let app = Router::new()
    .route("/protected", get(protected))
    .route("/authorize", post(authorize));

  let listener = tokio::net::TcpListener::bind("127.0.0.1:3000")
    .await
    .unwrap();
  tracing::debug!("listening on {}", listener.local_addr().unwrap());
  axum::serve(listener, app).await.unwrap();
}

async fn protected(claims: Claims) -> Result<String, AuthError> {
  // Send the protected data to user
  Ok(format!(
    "Welcome to the protected area :)\nYour data:\n{}",
    claims
  ))
}

async fn authorize(Json(payload): Json<AuthPayload>) -> Result<Json<AuthBody>, AuthError> {
  // Check if the user sent the credentials
  if payload.client_id.is_empty() || payload.client_secret.is_empty() {
    return Err(AuthError::MissingCredential);
  }
  // Here you can check the user credentials from a database
  if payload.client_id != "foo" || payload.client_secret != "bar" {
    return Err(AuthError::WrongCredentials);
  }
  let claims = Claims {
    sub: "b@b.com".to_owned(),
    company: "ACME".to_owned(),
    // Mandatory expiry time as UTC timestamp
    exp: 2000000000, // May 2033
  };
  // Create the authorization token
  let token = encode(&Header::default(), &claims, &KEYS.encoding)
    .map_err(|_| AuthError::TokenCreation)?;

  // Send the authorized token
  Ok(Json(AuthBody::new(token)))
}

impl Display for Claims {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    write!(f, "Email: {}\nCompany: {}", self.sub, self.company)
  }
}

impl AuthBody {
  fn new(access_token: String) -> Self {
    Self {
      access_token,
      token_type: "Bearer".to_string(),
    }
  }
}

#[async_trait]
impl<S> FromRequestParts<S> for Claims
where
  S: Send + Sync,
{
  type Rejection = AuthError;

  async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
    // Extract the token from the authorization header
    let TypedHeader(Authorization(bearer)) = parts
      .extract::<TypedHeader<Authorization<Bearer>>>()
      .await
      .map_err(|_| AuthError::InvalidToken)?;
    // Decode the user data
    let token_data = decode::<Claims>(bearer.token(), &KEYS.decoding,    &Validation::default())
      .map_err(|_| AuthError::InvalidToken)?;

    Ok(token_data.claims)
  }
}

impl IntoResponse for AuthError {
  fn into_response(self) -> Response {
    let (status, error_message) = match self {
      AuthError::WrongCredentials => (StatusCode::UNAUTHORIZED, "Wrong credentials"),
      AuthError::MissingCredential => (StatusCode::BAD_REQUEST, "Missing credentials"),
      AuthError::TokenCreation => (StatusCode::INTERNAL_SERVER_ERROR, "Token creation error"),
      AuthError::InvalidToken => (StatusCode::BAD_REQUEST, "Invalid token"),
    };
    let body = Json(json!({
      "error": error_message,
    }));
    (status, body).into_response()
  }
}

struct Keys {
  encoding: EncodingKey,
  decoding: DecodingKey,
}

impl Keys {
  fn new(secret: &[u8]) -> Self {
    Self {
      encoding: EncodingKey::from_secret(secret),
      decoding: DecodingKey::from_secret(secret),
    }
  }
}

#[derive(Debug, Serialize, Deserialize)]
struct Claims {
  sub: String,
  company: String,
  exp: usize,
}

#[derive(Debug, Serialize)]
struct AuthBody {
  access_token: String,
  token_type: String,
}

#[derive(Debug, Deserialize)]
struct AuthPayload {
  client_id: String,
  client-secret: String,
}

#[derive(Debug)]
enum AuthError {
  WrongCredentials,
  MissingCredential,
  TokenCreation,
  InvalidToken,
}
```

There are pieces of this code that I cannot understand. So I'll have to
look a bit deeper. There are many pieces to unpack. So the only place to
start is going to be from the top.


### Importing all of the required crates

The goal of this project is to create a server that listens on routes. With these routes we plan to create two different paths. `Authorize` and `Protected`. What we can do with is exactly what it sounds like. Signing in and authorizing. Qualifying a valid identity and receiving the protected data back.

We can accomplish this with using `axum`, `jsonwebtoken`, `once_cell`, `serde`, `serde_json` and `tracing_subscriber`. I'm not sure what `once_cell` and `tracing_subscriber`. The others you will have to understand more on your own. That will be out of scope for this one.

```rust
use axum::{
  async_trait,
  extract::FromRequestParts,
  http::{request::Parts, StatusCode},
  response::{IntoResponse, Response},
  routing::{get, post},
  Json, RequestPartsExt, Router,
};
use axum_extra::{
  headers::{authorization::Bearer, Authorization},
  TypedHeader,
};
use jsonwebtoken::{decode, encode, DecodingKey, EncodingKey, Header,
Validation};
use once_cell::sync::Lazy;
use serde::{Deserialize, Serialize};
use serde_json::json;
use std::fmt::Display;
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};
```

* `once_cell`: This is used to lazy load variables. It's mostly used with `Arc` or `Mutex` for synchronization primitives. It initializes the value on demand and avoids unnecessary recomputation across multi threaded environments.

* `tracing_subscriber`: Part of a larger `tracing` ecosystem. It provides a framework for structured, composable logging and diagnostics in Rust applications. It helps configure and set up tracing instrumentation in Rust projects. It provides various subscriber implementations, which are responsible for receiving tracing events and processing them in different ways. Printing to the console, writing to a file, or sending to a distributed tracing system. We can customize the logging behavior and choose which subscribers to use in the application.

### The main function and secrets

In this first part we are using the `Lazy` setup from `once_cell` that will do what we described above. It will create a static `KEYS` whenever it's needed across avoiding recomputations. We pull out the secret with `std::env::var("JWT_SECRET")` and we return `Keys::new(secret.as_bytes()`

We will use `#[tokio::main]` on our main function and allow it to be `async fn main()`. This will set us up for using tokio.

```rust
static KEYS: Lazy<Keys> = Lazy::new(|| {
  let secret = std::env::var("JWT_SECRET").expect("JWT_SECRET must be
  set");
  Keys::new(secret.as_bytes())
});

#[tokio::main]
async fn main() {
  tracing_subscriber::registry()
    .with(
      tracing_subscriber::EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| "example_jwt=debug".into()),
    )
    .with(tracing_subscriber::fmt::layer())
    .init();

  let app = Router::new()
    .route("/protected", get(protected))
    .route("/authorize", post(authorize));

  let listener = tokio::net::TcpListener::bind("127.0.0.1:3000")
    .await
    .unwrap();
  tracing::debug!("listening on {}", listener.local_addr().unwrap());
  axum::serve(listener, app).await.unwrap();
}
```

* We create a new tracing registry to act as a central hub for collecting and managing tracings spans and events. `tracing_subscriber::registry().with().init();` After init the method will be initialized to capture and process tracing events. We will collect had route events according to the specified filters and formatters.

* Inside of the `with()` we will have `tracing_subscriber::EnvFilter::try_from_default_env().unwrap_or_else(|_| "example_jwt=debug".into())` 

```rust
#[derive(Debug, Serialize, Deserialize)]
struct Claims {
  sub: String,
  company: String,
  exp: usize,
}

#[derive(Debug, Serialize)]
struct AuthBody {
  access_token: String,
  token_type: String,
}

#[derive(Debug, Deserialize)]
struct AuthPayload {
  client_id: String,
  client-secret: String,
}

#[derive(Debug)]
enum AuthError {
  WrongCredentials,
  MissingCredential,
  TokenCreation,
  InvalidToken,
}
```

```rust
async fn protected(claims: Claims) -> Result<String, AuthError> {
  // Send the protected data to user
  Ok(format!(
    "Welcome to the protected area :)\nYour data:\n{}",
    claims
  ))
}

async fn authorize(Json(payload): Json<AuthPayload>) -> Result<Json<AuthBody>, AuthError> {
  // Check if the user sent the credentials
  if payload.client_id.is_empty() || payload.client_secret.is_empty() {
    return Err(AuthError::MissingCredential);
  }
  // Here you can check the user credentials from a database
  if payload.client_id != "foo" || payload.client_secret != "bar" {
    return Err(AuthError::WrongCredentials);
  }
  let claims = Claims {
    sub: "b@b.com".to_owned(),
    company: "ACME".to_owned(),
    // Mandatory expiry time as UTC timestamp
    exp: 2000000000, // May 2033
  };
  // Create the authorization token
  let token = encode(&Header::default(), &claims, &KEYS.encoding)
    .map_err(|_| AuthError::TokenCreation)?;

  // Send the authorized token
  Ok(Json(AuthBody::new(token)))
}
```
