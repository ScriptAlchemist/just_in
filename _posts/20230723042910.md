---
title: 'Axum By Example (CORS)'
excerpt: 'The only way to understand code better. Is to keep reading more and
more code. There exists a github repo of solid examples. The perfect place to
learn more. This post is about the CORS example.'
coverImage: '/assets/blog/img_bin/axum_by_example_wizard_1_CORS.png'
date: '2023-07-23T04:29:10.023Z'
author:
  name: 'Justin Bender'
  picture: '/assets/blog/authors/bender.png'
ogImage:
  url: '/assets/blog/img_bin/axum_by_example_wizard_1_CORS.png'
---

# Axum By Example (CORS)

> ðŸ¦€ One of the best ways to understand code is to read more of it.
>
> I would like to take a second to welcome you to this article. I hope
> you're having a great day. Be safe and have fun!

[axum examples](https://github.com/tokio-rs/axum/tree/main/examples)

[CORS - axum examples](https://github.com/tokio-rs/axum/tree/main/examples/cors)

### What is Cross-Origin Resource Sharing (CORS)?

[CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) or Cross-Origin
Resource Sharing is an `HTTP-header` based mechanism that allows a server to
indicate any `origins` (domain, scheme, or port) other than its own from which a
browser should permit loading resources. CORS also relies on a mechanism by
which browsers make a "preflight" request to the server hosting the cross-origin
resource, in order to check that the server will permit the actual request.

For security reasons, browsers restrict cross-origin HTTP request initiated from
scripts. For example, `XMLHttpRequest` and the `Fetch API` follow the
`same-origin policy`. This means that a web application using those APIs can
only request resources form the same origin the application was loaded from
unless the response from other origins includes the right CORS headers.

> ðŸ’¬ The scope of the post is not to teach you all about CORS. I would like to
go over a few facts about CORS. So everyone can understand what is going on with
the program we are building.

The Cross-Origin resource sharing standard works by adding new `HTTP headers`
that let servers describe which origins are permitted to read that information
from a web browser. CORS failures result in errors but for security reasons,
specifics about the error are not available in JavaScript. All the code knows is
that an error occurred. You must check the browser console for more details.

#### CORS Examples

1. Same-Origin Requests (CORS Success)

Let's say you are browsing a web page on `https://www.example.com` and this page
wants to load an image from `https://images.example.com`. Since both the web
page and the image have the same origin `https://example.com`, this is a
same-origin request, and CORS will succeed. The browser allows this because it
trusts the same origin.

2. Cross-Origin Requests (CORS Failure)

Imagine you're on a web page from `https://www.example.com` that wants to fetch
some data from `https://api.exampleapi.com`. In this case, the request is coming
from a different origin that the target API. The browser will then check if
`https://api.exampleapi.com` has explicitly allowed `https://www.example.com` to
access its resources using CORS headers.

3. Missing CORS Headers (CORS Failure)

Let's say you have a website on `https://www.mysite.com` that wants to fetch
data form an API at `https://api.exampleapi.com`. But the API server does not
include the necessary CORS headers in its responses. The lack of proper CORS
headers will cause the browser to block the request, and CORS will fail.

4. Different Ports (CORS Failure)

Suppose your web page is running on `https://www.example.com` and attempts to
fetch data from a server at `https://api.example.com:3000`. Here, the port
number 3000 is different from the standard HTTP/HTTPS ports 80/443. If the API
server doesn't explicitly allow requests from `https://www.example.com` on port
3000, CORS will fail.

5. No Credentials with Credentials Required (CORS Failure)

Some APIs may require authentication credentials (like cookies or tokens) to
grant access to their resources. If your web page tries to access such an API
without providing the necessary credentials, CORS will fail, and the browser
will block the request.

---

## Axum CORS Example

Let's start with the `Cargo.toml` file to see exactly what would be required for
this project. We will pull in a few crates from the `tokio` stack.

* `axum`
* `tokio`
* `tower-http`


`Cargo.toml`:

```rust
[package]
name = "example-cors"
version = "0.1.0"
edition = "2021"
publish = false

[dependencies]
axum = { path = "../../axum" }
tokio = { version = "1.0", features = ["full"] }
tower-http = { version = "0.4.0", features = ["cors"] }
```

Let's checkout the whole file. Before we break it down into smaller sections, to
talk about.

`main.rs`:

```rust
use axum::{
    http::{HeaderValue, Method},
    response::{Html, IntoResponse},
    routing::get,
    Json, Router,
};
use std::net::SocketAddr;
use tower_http::cors::CorsLayer;

#[tokio::main]
async fn main() {
    let frontend = async {
        let app = Router::new().route("/", get(html));
        serve(app, 3000).await;
    };

    let backend = async {
        let app = Router::new().route("/json", get(json)).layer(
            // see https://docs.rs/tower-http/latest/tower_http/cors/index.html
            // for more details
            //
            // pay attention that for some request types like posting content-type: application/json
            // it is required to add ".allow_headers([http::header::CONTENT_TYPE])"
            // or see this issue https://github.com/tokio-rs/axum/issues/849
            CorsLayer::new()
                .allow_origin("http://localhost:3000".parse::<HeaderValue>().unwrap())
                .allow_methods([Method::GET]),
        );
        serve(app, 4000).await;
    };

    tokio::join!(frontend, backend);
}

async fn serve(app: Router, port: u16) {
    let addr = SocketAddr::from(([127, 0, 0, 1], port));
    let listener = tokio::net::TcpListener::bind(addr).await.unwrap();
    axum::serve(listener, app).await.unwrap();
}

async fn html() -> impl IntoResponse {
    Html(
        r#"
        <script>
            fetch('http://localhost:4000/json')
              .then(response => response.json())
              .then(data => console.log(data));
        </script>
        "#,
    )
}

async fn json() -> impl IntoResponse {
    Json(vec!["one", "two", "three"])
}
```

### Let's break down main

We will use all of the packages that we brought into our `Cargo.toml`. I
personally don't have much to say about this section. It would just be repeating
myself. So we can just look at the code it self and see what we import.

You may notice that we get the `CorsLayer` from the `tower_http` crate. This
doesn't live in `axum`.

```rust
use axum::{
    http::{HeaderValue, Method},
    response::{Html, IntoResponse},
    routing::get,
    Json, Router,
};
use std::net::SocketAddr;
use tower_http::cors::CorsLayer;
```

Before we move to main. Let's checkout some of the supporting functions. We have
the `html()`, `json()` and `serve(app: Router, port: u16)`

### Functions

#### `html()`

* `r#""#` is a raw string literal. This allows us to use symbols, quotes new
  lines without having to escape characters.

Honestly it's just a basic filler html for this project. We could do something a
bit more complex, but we will keep it simple.

```rust
async fn html() -> impl IntoResponse {
    Html(
        r#"
        <script>
            fetch('http://localhost:4000/json')
              .then(response => response.json())
              .then(data => console.log(data));
        </script>
        "#,
    )
}
```

#### `json()`

* Very basic `Json` setup with a vector with 3 values. I'm not 100% sure the
  inner workings for this. For now we will just have the simple `json()`
  function setup.

```rust
async fn json() -> impl IntoResponse {
    Json(vec!["one", "two", "three"])
}
```

#### `serve()`

```rust
async fn serve(app: Router, port: u16) {
    let adder = SocketAddr::from([127, 0, 0, 1], port));
    let listener = tokio::net::TcpListener::bind(addr).await.unwrap();
    axum::serve(listener, app).await.unwrap();
}
```

