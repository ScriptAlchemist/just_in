---
title: "Why are variable typing of children not passed with context?"
excerpt:
  "You would sometimes assume that typing would have certain features.
  We are spoiled but there is one type problem. I wanted to solve for
  myself."
coverImage: "/assets/blog/img_bin/discriminatedContextExample.png"
date: "2025-12-10T05:11:17.286Z"
author:
  name: "Justin Bender"
  picture: "/assets/blog/authors/bender.png"
ogImage:
  url: "/assets/blog/img_bin/discriminatedContextExample.png"
---

## Why doesn't variable typing of children pass with context?

TLDR: Here is the repo I'll be talking about in this article. If you'd
rather look at the code.

> NPM Repo:
> [@bender-tools/react-discriminated-union-context](https://www.npmjs.com/package/@bender-tools/react-discriminated-union-context?activeTab=readme)

For those that want to hear my though process. Welcome.

There was a task I tried 3 other times. A typing problem that has an
easy solution, but builds up with complexity. Having children of a
parent component using useContext. How to understand which values are
accessible with a discriminated union as the type.

```typescript
// Define your discriminated union type
type AuthStateProps =
  | { status: "idle" }
  | { status: "loading" }
  | { status: "authenticated"; user: { name: string; email: string } }
  | { status: "error"; error: string };
```

So if we take a simple discriminated union. Where the `status` needs to
be a value and it's different for everyone. Let's build out a better
understanding of the framework we are using. This is React based if you
didn't understand that already. We will be using `createContext` and
`useContext` functions from the framework.

That's where the problem lies. In how the context works. I'll admit
right now. I don't know what the context is. How it functions at this
time. I was focused more on a solution I stumbled on. After this. I'll
likely look back. For a way it could be cleaner.

A basic layout of how the problem looks. Where we will create the
context and the function to pull out data. Using types as much as
possible.

```typescript
const AuthStateContext = createContext<AuthStateProps>(
  {} as AuthStateProps
);

export const useAuthState = () => {
  return useContext(AuthStateContext);
};
// Use in a provider
const Parent(props: AuthStateProps) {

  return (
    <AuthContext.Provider value={props}>
    {!!props.status === 'authenticated' ? <Profile /> : <Login />}
    </AuthContext.Provider>
  );
}
```

The final solutions looks a bit more like this:

```typescript
// Create the context with the discriminant key
const { Context: AuthContext, useContext: useAuthContext } =
  createDiscriminatedContext<AuthState, "status">("status");
// Use in a provider
const Parent(props: AuthStateProps) {

  return (
    <AuthContext.Provider value={auth}>
    {!!props.status === 'authenticated' ? <Profile /> : <Login />}
    </AuthContext.Provider>
  );
}
```

... In progress, finishing soon.
