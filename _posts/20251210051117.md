---
title: "Why are variable typing of children not passed with context?"
excerpt:
  "You would sometimes assume that typing would have certain features.
  We are spoiled but there is one type problem. I wanted to solve for
  myself."
coverImage: "/assets/blog/img_bin/discriminatedContextExample.png"
date: "2025-12-10T05:11:17.286Z"
author:
  name: "Justin Bender"
  picture: "/assets/blog/authors/bender.png"
ogImage:
  url: "/assets/blog/img_bin/discriminatedContextExample.png"
---

# Why doesn't variable typing of children pass with context?

## Table of Contents

## Understanding the problem (basic discriminated union setup with context)

TLDR: Here is the repo I'll be talking about in this article. If you'd
rather look at the code.

> NPM Repo:
> [@bender-tools/react-discriminated-union-context](https://www.npmjs.com/package/@bender-tools/react-discriminated-union-context?activeTab=readme)

For those that want to hear my though process. Welcome. You would
sometimes assume that typing would have certain features. We are spoiled
but there is one type problem. I wanted to solve for myself.

There was a task I tried 3 other times. A typing problem that has an
easy solution, but builds up with complexity. Having children of a
parent component using useContext. How to understand which values are
accessible with a discriminated union as the type.

```typescript
// Define your discriminated union type
type AuthStateProps =
  | { status: "idle" }
  | { status: "loading" }
  | { status: "authenticated"; user: { name: string; email: string } }
  | { status: "error"; error: string };
```

If we take a simple discriminated union. Where the `status` needs to be
a value and it's different for everyone. Let's build out a better
understanding of the framework we are using. This is React based if you
didn't understand that already. We will be using
[createContext and useContext](https://react.dev/learn/passing-data-deeply-with-context)
functions from the framework.

That's where the problem lies. In how the context works. I'll admit
right now. I don't know what the context really is. How it functions at
this time. Was focused more on a solution that was stumbled upon. After
this. I'll likely look back. For a way it could be cleaner.

A basic layout of how the problem looks. Where we will create the
context and the function to pull out data. Using types as much as
possible.

```typescript
const AuthStateContext = createContext<AuthStateProps>(
  {} as AuthStateProps
);

export const useAuthState = () => {
  return useContext(AuthStateContext);
};
// Use in a provider
const Parent(props: AuthStateProps) {

  return (
    <AuthContext.Provider value={props}>
    {!!props.status === 'authenticated' ? <Profile /> : <Login />}
    </AuthContext.Provider>
  );
}
```

Let's look in the Profile component:

```typescript
function Profile() {
  // When you pass the expected discriminant value, the type is narrowed
  const auth = useAuthContext();
  /*
    auth is typed as:
    { status: 'authenticated' | 'idle' | 'loading' | 'error'; }

    Could also use
    const { status } = useAuthContext();
  */

  // This auth.user.name would error here. The context doesn't know that we are inside of the parent components logic.
  return <div>Welcome, {auth.user.name}!</div>;
}
```

We end up having to do some sort of guarding inside of the children
component. Cause they do not understand the state above them in regards
to context.

The easy solution is:

```typescript
const auth = useAuthContext();
const { status } = auth;
const user = "user" in auth ? auth.user : undefined;
/*
  If you're in a large component. It becomes verbose.
  
  const value1 = "value1" in auth ? auth.value1 : undefined;
  const value2 = "value2" in auth ? auth.value2 : undefined;
  const value3 = "value3" in auth ? auth.value3 : undefined;
  const value4 = "value4" in auth ? auth.value4 : undefined;
  const value5 = "value5" in auth ? auth.value5 : undefined;
  const value6 = "value6" in auth ? auth.value6 : undefined;
  const value7 = "value7" in auth ? auth.value7 : undefined;
  const value8 = "value8" in auth ? auth.value8 : undefined;
  const value9 = "value9" in auth ? auth.value9 : undefined;
  const value10 = "value10" in auth ? auth.value10 : undefined;
*/
```

Let's be honest. That's likely fine for most applications. There isn't
much wrong with that. Until we start getting to large pages. With many
different variation of internal components.

Let's look at the full working code.

```typescript
const AuthStateContext = createContext<AuthStateProps>(
  {} as AuthStateProps
);

export const useAuthState = () => {
  return useContext(AuthStateContext);
};
// Use in a provider
const Parent(props: AuthStateProps) {

  return (
    <AuthContext.Provider value={props}>
    {!!props.status === 'authenticated' ? <Profile /> : <Login />}
    </AuthContext.Provider>
  );
}

function Profile() {
  const auth = useAuthContext();
  const { status } = auth;
  const user = "user" in auth ? auth.user : undefined;

  return <div>Welcome, {auth.user.name}!</div>;
}
```

> This solution does not allow those child components to be composable.
> They are locked to the pages' context.

> The login component would be very similar so we will focus on this
> single example for now.

## Typing out the discriminated props for context

The solution that I want. Removes all that extra annoyance, gives error
and guidance where possible. To the developers after me. Can understand
how to use these. With some guardrails.

I'd prefer that it would just understand. That the component is only
used inside of the parent component. Which is only allowed to render if
the `status === 'authenticated'`. Alas, it cannot.

> Can't we just update the linting rules to yell at us? Maybe?

Recently stumbled on something called _overloading_ a hook.

### What is an overloaded hook (function overloading in TypeScript)?

Function overloading in TypeScript lets you define multiple type
signatures for the same function name. Each signature describes a
different way to call the function with different parameter types and
return types. The actual implementation comes last and must handle all
the cases.

```typescript
// Multiple signatures for the SAME function name - this is overloading
function useAuthContext(status: "authenticated"): {
  user: { name: string; email: string };
};
function useAuthContext(status: "error"): { error: string };
function useAuthContext(status: "loading"): Record<string, never>;
function useAuthContext(status: "idle"): Record<string, never>;
function useAuthContext(): AuthStateProps;
// The implementation signature (not visible to consumers)
function useAuthContext(status?: AuthStateProps["status"]) {
  // actual implementation here
}
```

### Why can we have the same function name multiple times?

TypeScript distinguishes between _overload signatures_ and the
_implementation signature_:

1. **Overload signatures** (the repeated `function useAuthContext(...)`
   lines) tell TypeScript: "When someone calls this function with _these
   specific arguments_, return _this specific type_."

2. **Implementation signature** (the final one with the actual body) is
   where the logic lives. It must be compatible with ALL the overload
   signatures above it.

When you call the function, TypeScript looks at your arguments and
matches them against the overload signatures _in order from top to
bottom_. The first matching signature determines the return type.

This is the key insight: by passing the discriminant value
(`"authenticated"`) to the hook, TypeScript can return the _exact
narrowed type_ instead of the full union. The overloads create a mapping
from input â†’ specific output type.

Which is interesting and something I haven't used much. So let's dig
into using it for this specific solution. It sounds like a perfect use
of this overloading.

The final solutions looks a bit more like this:

```typescript
// Create the context with the discriminant key
const { Context: AuthContext, useContext: useAuthContext } =
  createDiscriminatedContext<AuthState, "status">("status");
// Use in a provider
const Parent(props: AuthStateProps) {

  return (
    <AuthContext.Provider value={auth}>
    {!!props.status === 'authenticated' ? <Profile /> : <Login />}
    </AuthContext.Provider>
  );
}
```

... In progress, finishing soon.
